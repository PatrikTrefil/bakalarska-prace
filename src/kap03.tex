\chapter{Vývojová dokumentace}\label{ch:vyvojova-dokumentace}

Tato kapitola popisuje vývoj aplikace.
Mezí hlavní části patří návrh uživatelského rozhraní formou wireframů, výběr technologií, které budeme používat, tvorba datové modelu a architektury.
Mimo to jsou zde popsány i řešení menších problémů, které si vyžadují vysvětlení jako je řešení autentizace, GDPR, soukromí uživatelů apod.

\section{Návrh řešení}\label{sec:navrh-reseni}

Jelikož chceme, aby byla aplikace dostupná jak na počítačích, tak na mobilních zařízeních, nabízí se dvě možnosti.
První možností je vyvinout mobilní aplikaci a desktopovou aplikaci zvlášť.
Druhou možností je vyvinout webovou aplikaci s responzivním rozhraním, která bude dostupná na všech zařízeních.
Jelikož nepotřebujeme žádné nativní funkce zařízení, tak je výhodnější vyvinout pouze jednu webovou aplikaci.
Webová aplikace má také výhodu v tom, že ji není potřeba instalovat a aktualizovat.
Nezapomeňme zmínit, že zadavatel má již zkušenosti s provozem webových aplikací a má již existující infrastrukturu.

Budeme se snažit použít co nejvíce již existujícího software, abychom se vyhnuli duplicitě práce a zároveň zjednodušili údržbu aplikace.
Naším cílem bude vybrat software, který nám dá dostatek flexibility a zároveň bude dostatečně stabilní a udržitelný.
Nemáme rozpočet na použití placeného software a proto budeme vybírat pouze z open-source řešení.
Systém chceme navrhnout tak, aby bylo možné v budoucnu vyměnit některé komponenty za komplexnější placené řešení.

Abychom zajistili spokojenost zadavatele, budeme se snažit pravidelně prezentovat výsledky vývoje a získávat zpětnou vazbu.
Na začátku vývoje budeme směřovat k vytvoření minimálního životaschopného produktu, který bude mít základní funkce.

\section{Návrh uživatelského rozhraní}\label{sec:navrh-uzivatelskeho-rozhrani}

Jak již víme z analýzy požadavků budeme potřebovat navrhnout rozhraní pro plnitele úkolů a také pro terapeuty.
Předpokládáme, že uživatelé mají nízké technické dovednosti a proto se budeme snažit navrhnout co nejjednodušší rozhraní.
Abychom předešli vývoji rozhraní, které by zadavatel nepovažoval za vhodné, tak vytvoříme wireframy, které necháme zadavatelem schválit.
Výsledné wireframy naleznete v přílohách práce\ \ref{sec:wireframy-uzivatelskeho-rozhrani}.

\section{Výběr technologií}\label{sec:vyber-technologii}

V této sekci se budeme zabývat výběrem technologií, které budeme používat při vývoji aplikace.
Chceme volit populární nástroje, jelikož programátoři, kteří budou aplikaci v budoucnu rozšiřovat, je pravděpodobně budou znát.
Zároveň také chceme co nejméně komplikovat workflow a deployment, abychom zbytečně nezvyšovali nároky na programátory, kteří budou aplikaci v budoucnu rozšiřovat.
Jelikož nemáme rozpočet na placené aplikace, tak musíme vybírat primárně z open-source řešení a nebo vyjednat smlouvu s komerčními firmami.

\subsection{Software pro práci s formuláři}\label{subsec:software-pro-praci-s-formulari}

Software pro práci s formuláři je klíčovou součástí aplikace.
Musíme zvážit v jakém formátu definice formulářů ukládat, jaký software použít pro tvorbu formulářů, vykreslení formulářů a sběr odpovědí.

Existuje mnoho knihoven pro vykreslování formulářů na základě schématu.
Existuje však velmi málo knihoven pro tvorbu formulářů.
Knihovny pro tvorbu formulářů jsou náročné na vývoj a proto jsou velmi často součástí pouze placených řešení.

Jedna z takových knihoven je vyvíjena firmou \href{https://www.vazco.eu/}{Vazco}.
Knihovna je však součástí placeného produktu.
Firmu jsem kontaktoval a dostal jsem potvrzení, že můžeme jejich knihovnu pro tento projekt použít.
Hned po obdržení potvrzení však firma přestala reagovat na mé e-maily.
Navzdory několika dalším pokusům o kontaktování firmy dopadlo toto jednání neúspěšně.

Další alternativou je knihovna \href{https://formilyjs.org/}{Formily}.
Formily je velký open-source projekt, který dosáhl poměrně velké popularity.
Za projektem navíc stojí velká komerční firma Alibaba.
Projekt je aktivně vyvíjen, ale bohužel v době volby technologie nebyla dostupná dokumentace v anglickém jazyce.
Z důvodu chybějící dokumentace jsem tuto knihovnu musel zavrhnout.

Posledním velkým projektem z oblasti knihoven pro tvorbu formulářů, který jsem našel je \href{https://form.io/}{Form.io}.
Tento projekt byl již zmíněn v sekci o již existujících řešení\ \ref{ch:analyza-existujicich-reseni-pro-praci-s-formulari}.
Tentokrát se nebudeme dívat na placené služby, ale na open-source jádro projektu, které má licenci Open Software License 3.0, což dovoluje komerční použití.
Zásadní výhodou tohoto projektu je, že řeší všechny problémy týkající se správy formulářů - formát definic formulářů, tvorbu formulářů, vykreslení formulářů a sběr odpovědí.
Produkt má spoustu dokumentace, kvalitní API a je stále aktivně vyvíjen.
Řešení navíc obsahuje základní systém pro správu uživatelů.
Projekt je zastřešen komerční firmou, což zvyšuje jeho dlouhodobou udržitelnost.
Nevýhodou je, že použití vlastního autentifikačního poskytovatele je dostupné pouze v placených verzích.
Software Form.io je využíván pro provoz pohraničních sil Britské vlády (viz \href{https://www.youtube.com/watch?v=nuf46N5vU34}{video z konference CamundaCon}).
Dle oficiálních stránek Form.io je také využíván organizacemi jako Visa či ICANN\@.

Po zvážení těchto možností jsem se rozhodl použít jádro produktu Form.io.
Některé placené funkce by použití ulehčily, ale nejsou pro tento projekt nezbytně nutné.
Zároveň se nabízí jednoduchý přechod na placenou verzi po nárazu na limity bezplatné verze.

\subsection{Frontend aplikace}\label{subsec:frontend-aplikace}

\begin{description}
    \item[Bootstrap]
    Jednoduchý způsob jak pracovat s CSS\@.
    Knihovna je velmi populární, takže je pravděpodobné, že ji ostatní programátoři znají.
    Alternativy jako Tailwind CSS nabízejí větší míru flexibility, ale neposkytují žádné hotové komponenty.
    Tento projekt nemá za cíl vytvářet vlastní designovou identitu, proto je výhodnější použít hotové komponenty, které Bootstrap nabízí.
    \item[JavaScript/TypeScript]
    Výchozí volba pro programování webových stránek.
    TypeScript poskytne statickou typovou kontrolu, což pomůže předejít mnoha chybám.
    Přestože TypeScript zkomplikuje a zpomalí vývoj, tak se, dle mého názoru, z dlouhodobého hlediska vyplatí jej používat.
    \item[React]
    React je dle průzkumu \href{https://2022.stateofjs.com/en-US/libraries/front-end-frameworks/}{State of JavaScript} z roku 2022 nejpoužívanější front-end framework.
    React je vyspělý framework, který má velkou komunitu a mnoho existujících knihoven.
    \item[NextJS]
    Místo volby jednotlivých balíků pro základy řešení routing, middleware, sdílených layoutů apod.\ zvolme populární framework, který všechny tyto funkce poskytuje.
    Jedná se o full-stack framework, takže jej využijme i na serverovou část.
    Tím se vyhneme nutnosti zakládat další projekt.
    \item[react-bootstrap]
    Tato knihovna značně zjednodušuje použití knihovny Bootstrap v React aplikacích a navíc zajistí alespoň základní webovou přístupnost.
    \item[react-i18next]
    Aplikace bude podporovat více jazyků a proto je vhodné použít knihovnu, která nám usnadní práci s překlady.
    Oproti alternativám jako \href{https://github.com/airbnb/polyglot.js}{Polyglot.js} nebo \href{https://github.com/formatjs/formatjs}{Format.js} nabízí knihovna react-i18next více funkcí.
    Knihovna react-i18next je s 2.9 milióny stažení za týden nejpopulárnější ze zvažovaných knihoven dle počtu stažení z npm registry.
    \item[React formio]
    Knihovna pro vykreslování formulářů na základě schématu.
    Tato oficiální knihovna je součástí projektu Form.io.
    \item[NextAuth.js]
    Knihovna pro autentifikaci uživatelů v prohlížeči i na serveru.
    Ukázalo se, že Formio React není vhodný pro autentifikaci uživatele.
    První důvod je, že vyžaduje, aby si vývojář psal vlastní logiku pro ochranu stránek, přesměrování apod.
    To zbytečně vytvářelo prostor pro chyby.
    Druhý důvod je ten, že inicializace autentifikace se dělala pouze na klientovi, jelikož knihovna nepodporuje server-side rendering, což mělo negativní vliv na výkon aplikace.
    Třetí důvod je špatná dokumentace knihovny.
    Jako alternativy jsem zvažoval Passport.js a NextAuth.js.
    Passport.js je více nízko-úrovňový a opět vyžaduje, aby si vývojář psal vlastní logiku.
    Oproti Formio React má však pěknou dokumentaci.
    Poslední výhodou použití jiné knihovny než Formio React je to, že máme v kódu vrstvu abstrakce a tedy kód webové aplikace není závislý na konkrétním autetifikačním systému.
    \item[Zod]
    Pro validaci dat na serveru a validaci formulářů na klientovi využijeme validační knihovnu.
    Knihovnu Zod jsem zvolil jelikož má rozhraní, se kterým se dobře pracuje.
    \item[React hook form]
    Aplikace bude obsahovat formuláře pro přihlášení, správu uživatelů, tvorbu úkolů a mnoho dalších.
    Pro lepší práci s formuláři využijeme knihovnu.
    Díky této knihovně budeme moci snadno validovat formuláře, získávat hodnoty formulářů a zobrazovat chybové hlášky.
    Lze zvážit také knihovnu \href{https://formik.org}{Formik}.
    Recenze na internetu byly stejně dobré jako pro React hook form, ale integrace s validační knihovnou Zod existuje pouze jako \href{https://github.com/robertLichtnow/zod-formik-adapter}{komunitní balíček}.
    React hook form má oficiální integraci s validační knihovnou zod pomocí \href{https://github.com/react-hook-form/resolvers}{balíčku resolvers}.
    \item[Tanstack query]
    Aplikace bude obsahovat mnoho dat, která budou načítána ze serveru.
    Pro zvýšení kvality kódu a zlepšení výkonu aplikace využijeme knihovnu.
    Populární řešení jsou Tanstack query a SWR\@.
    Tanstack query nabízí více funkcí a mnoho z nich nám značně ulehčí práci.
    Tanstack query například nabízí podporu pro stránkování.
    \item[Tanstack table]
    Aplikace bude obsahovat velké množství tabulek.
    Vykreslování velkých tabulek efektivně je náročný úkol.
    Vzhledem k tomu, že používáme knihovnu Tanstack query, tak se nabízí použít i knihovnu Tanstack table.
    Výhodou této knihovny je, že je velmi flexibilní a umožňuje vytvářet vlastní komponenty pro vykreslování tabulek.
    Jedná se o tzv. \textit{headless UI} knihovnu.
    \item[Recharts]
    Aplikace bude potřebovat vizualizovat sesbíraná data a proto potřebujeme knihovnu na vykreslování grafů.
    Pro tyto účely byly zváženy knihovny \href{https://github.com/airbnb/visx}{visx} od AirBnB, \href{https://github.com/apache/echarts} od Apache a \href{https://github.com/recharts/recharts}{Recharts}.
    Knihovna visx má velmi komplikovanou dokumentaci i příklady.
    Knihovna má evidentně strmou výukovou křivku a pro naše účely je zbytečně komplexní.
    Knihovna echarts je velmi populární, ale nemá oficiální podporu pro React.
    Knihovna Recharts má kvalitní dokumentaci obsahující jak jednoduché tak složitější příklady a navíc má přímou podporu pro React.
\end{description}

\subsection{Middleware}\label{subsec:middleware}

Pro komunikaci mezi klientem a serverem využijeme middleware.
To nám automaticky zajistí typovou bezpečnost, serializaci dat a zlepší vývojářskou zkušenost.
Abychom neztratili interoperabilitu serveru s ostatními aplikacemi, použijeme knihovnu, která umožní vytvořit i REST API\@.
Mezi populární volby řešení patří knihovny \href{https://grpc.io/}{gRPC} od firmy Google, \href{https://www.npmjs.com/package/json-rpc-2.0}{json-rpc-2.0} implementující \href{https://www.jsonrpc.org/specification}{standard JSON-RPC 2.0}  a \href{https://trpc.io/}{tRPC}.
Knihovna gRPC však nefunguje v prohlížeči (viz \href{https://grpc.io/blog/state-of-grpc-web/}{článek}).
Knihovna tRPC má skvělou podporu pro TypeScript a je kompatibilní s knihovnou NextAuth.js.
Knihovna tRPC je oproti knihovně json-rpc-2.0 značně populárnější, nabízí více funkcí a má aktivnější vývoj.

\subsection{Backend aplikace}\label{subsec:backend-aplikace}

\begin{description}
    \item[nginx]
    Veškeré požadavky na server budou směrovány přes reverse proxy.
    To nám umožní konfigurovat routing, SSL certifikáty apod.
    Mezi další zvážené možnosti patří \href{https://httpd.apache.org/}{Apache HTTP Server}.
    Po prostudování dokumentace obou nástrojů jsem dospěl k názoru, že nginx má lepší dokumentaci a čitelnější formát konfigurace.
    Nginx má navíc největší podíl z počítačů na internetu dle \href{https://news.netcraft.com/archives/category/web-server-survey/}{průzkumu z března 2023}.
    \item[NextJS]
    Důvody popsány v sekci~\ref{subsec:frontend-aplikace}.
    \item[Form.io]
    Důvody popsány v sekci~\ref{subsec:software-pro-praci-s-formulari}.
    \item[MongoDB]
    Form.io server podporuje pouze MongoDB pro ukládání dat\@.
    \item[PostgreSQL]
    Potřebujeme databázi pro ukládání dat o úkolech a také nedokončené odpovědi na dotazníky.
    Chceme bezplatné řešení, které je dostatečně stabilní a jeho licence umožňuje komerční použití.
    Výběr konkrétního řešení není příliš důležitý z následujících důvodů.
    Naše nároky na databázový systém jsou poměrně nízké a navíc budeme používat abstrakci nad databází, která nám umožní databázový systém kdykoliv vyměnit.
    PostgreSQL patří mezi nejlepší řešení splňující všechny naše požadavky.
    \item[Prisma]
    Abychom zajistili dobrou modifikovatelnost celého systému použijeme techniku object-relational mapping.
    Mezi populární volby patří knihovny \href{https://github.com/drizzle-team/drizzle-orm}{Drizzle ORM}, \href{https://github.com/typeorm/typeorm}{TypeORM} a \href{https://github.com/prisma/prisma}{Prisma}.
    Knihovna Prisma je nejvyspělejší a nejpopulárnější z těchto knihoven co se týče počtu stažení za týden z npm registry.
    Knihovna Prisma je navíc vyvíjena komerční firmou, což zvyšuje její dlouhodobou udržitelnost.
\end{description}

\subsection{Nástroje}\label{subsec:nastroje}

\begin{description}
    \item[Prettier]
    Formátování kódu.
    \item[ESLint]
    Statická analýza kódu.
    \item[Github Workflows]
    Continuous integration.
    \item[TypeDoc]
    Implementuje generování dokumentace z dokumentačních komentářů dle standardu \href{https://tsdoc.org/}{TSDoc}.
    Alternativou je \href{https://github.com/dotnet/docfx}{DocFX}, ale to je nástroj napsaný v C\#.
    Tento nástroj nemá npm balíček, což komplikuje integraci do našeho projektu.
    Jelikož TypeDoc implementuje stejný standard a jeho použití je v našem případě jednodušší, zvolil jsem jej pro tento projekt.
    \item[Vitest]
    Původně jsem používal pro testování knihovnu \href{https://jestjs.io/}{Jest}, ale narazil jsem na problémy s konfigurací.
    Složité chybové hlášky a nedostatečná dokumentace mě přiměly zkusit jinou knihovnu.
    Zvolil jsem knihovnu Vitest, se kterou jsem měl vělmi dobrou zkušenost.
    \item[Docusaurus]
    Původně jsem používal \href{https://docs.github.com/en/communities/documenting-your-project-with-wikis/about-wikis}{Github Wiki}, ale časem se ukázalo, že je pro tento projekt nevhodná.
    Github Wiki chybí podpora pro diagramy jako kód a také nelze zahrnout automaticky generovanou dokumentaci.
    Proto jsem zvažoval další alternativy jako \href{https://www.mkdocs.org/}{MkDocs}, \href{https://www.gitbook.com/}{GitBook} a \href{https://docusaurus.io/}{Docusaurus}.
    Docusaurus působil moderně, jednoduše a všechny jeho funkce jsou zdarma.
    Docusaurus má mnoho rozšíření jako například podporu pro diagramy jako kód.
    Docusaurus má oficiální plugin pro \href{https://mermaid.js.org/}{MermaidJS}, což je nástroj pro tvorbu diagramů.
    Ukázalo se, že MermaidJS není vhodný pro náš projekt, protože nemá dobrou podporu \href{https://c4model.com/}{diagramů C4 modelu}, které používáme pro dokumentaci architektury.
    Díky velkému ekosystému nástroje Docusaurus však existuje i komunitní plugin pro podporu PlantUML diagramů, který má skvělou podporu diagramů C4 modelu.
\end{description}


\section{Architektura}\label{sec:architektura}

Nyní navrhněme architekturu aplikace.
Pro její popis použijeme \href{https://c4model.com/}{C4 model}, který poskytuje jednoduchou sadu abstrakcí pro popis architektury.
Alternativy jako \href{https://www.opengroup.org/archimate-forum}{ArchiMate} míří na popis enterprise systémů a jsou pro nás zbytečně komplexní.
Popíšeme 3 úrovně abstrakce - kontext, kontejnery a komponenty.
Čtvrtou vrstvu, která popisuje mapování komponent na jednotlivé soubory obsahující zdrojový kód vynecháme.
Čtvrtou vrstvu bychom mohli automaticky vygenerovat ze zdrojového kódu, ale myslím si, že nám v tomto případě nepřináší žádnou hodnotu.

\subsection{Kontext}\label{subsec:kontext}

\begin{figure}[H]
    \includegraphics[width=0.9\textwidth]{diagrams/architecture/context}
    \caption{C4 model - Systémový kontext}\label{fig:architecture-context}
\end{figure}

\subsection{Kontejnery}\label{subsec:kontejnery}

\begin{figure}[H]
    \includegraphics[width=0.9\textwidth]{diagrams/architecture/containers}
    \caption{C4 model - Kontejnery}\label{fig:architecture-containers}
\end{figure}

\begin{tcolorbox}
    Pokud je vztah mezi dvěma kontejnery vyznačený jako gateway, znamená to, že komunikace probíhá skrze prostředníka, který poskytuje vrstvu abstrakce.
    Gateway snižuje provázanost komunikujících systémů (coupling) a zajišťuje modifikovatelnost.
    Bližší informace o tomto vzoru lze nalézt v \href{https://martinfowler.com/articles/gateway-pattern.html}{článku Gateway} od Martin Fowler.
\end{tcolorbox}

\begin{tcolorbox}
    Monitoring server monitoruje všechny ostatní kontejnery.
    Relace byly vynechány pro zachování čitelnosti diagramu.
\end{tcolorbox}

Správa formulářů bude realizována pomocí softwaru Form.io.
Tento software nemá funkci pro ukládání nedokončených vyplnění formulářů.
Proto potřebujeme separátní komponentu a databázi pro tento účel.

\subsection{Komponenty}\label{subsec:komponenty}

\subsubsection{Webová aplikace}

\begin{figure}[H]
    \includegraphics[width=0.9\textwidth]{diagrams/architecture/webApplicationComponent}
    \caption{C4 model - Komponenta webová aplikace}\label{fig:architecture-component-web-application}
\end{figure}


\section{Nasazení}\label{sec:deployment}

\begin{figure}[H]
    \includegraphics[width=0.9\textwidth]{diagrams/deployment}
    \caption{Diagram nasazení}\label{fig:deployment}
\end{figure}


\section{Ukládání dat}\label{sec:ukladani-dat}

\subsection{Logický datový model}\label{subsec:logicky-datovy-model}

Nyní popíšeme jak data budete ukládat na logické úrovni.
Nebudeme se však zabývat detaily ukládání dat o uživatelích a formulářích, jelikož o to se stará software Form.io.
Entity, jejichž reprezentací se nechceme zabývat, jsou označeny šedou barvou.
Budeme se zabývat ukládáním úkolů a částečných vyplnění formulářů.
Zvolme relační datový model pro modelování těchto dat.
Třídy v UML diagramu budou reprezentovat tabulky v databázi.
Pro stav úkolu budeme potřebovat místo tradičních dvou stavů (dokončený a nedokončený) stavy tři.
Důvody k tomuto rozhodnutí jsou blíže popsány v sekci\ \ref{sec:propojeni-spravy-ukolu-a-spravy-formularu}.

\begin{figure}[H]
    \includegraphics[width=0.9\textwidth]{diagrams/logicalDataModel}
    \caption{Logický datový model}\label{fig:logical-data-model}
\end{figure}

\subsection{Správa dat o nedokončených vyplnění formulářů}\label{subsec:sprava-dat-o-nedokoncenych-vyplneni-formularu}

Plnitel si může vytvořit koncept pro libovolný dotazník.
Při odevzdání dotazníku informuje systém spravující formuláře automaticky pomocí webhook systém spravující nedokončené vyplnění formulářů.
Díky tomu nezůstávají nedokončené vyplnění formulářů v systému navždy.
Pokud však tento webhook selže, nedokončené vyplnění formuláře v systému zůstane.
Tato situace je velmi nepravděpodobná, takže ji nebudeme řešit.
Pokud by se v průběhu užívání ukázalo, že se jedná o větší problém než se předpokládalo, lze zavést omezení na životnost konceptu.
Například bychom mohli ukládat pouze koncepty, které byly použity v posledních 30 dnech.
Tím bychom zajistili, že i pokud webhook selže, tak se koncept v systému nezachová déle než 30 dní.


\section{Soukromí uživatelů}\label{sec:soukromi-uzivatelu}

Aplikace pracuje s citlivými daty a proto je pro nás bezpečnost na prvním místě.
Tato sekce se věnuje krokům, které jsme podnikli pro zajištění maximální bezpečnosti a soukromí uživatelů.

Každá změna v kódu prochází bezpečnostní statickou analýzou, kterou poskytuje nástroje \href{https://codeql.github.com/}{CodeQL}.

Pravidelně probíhá kontrola všech závislostí nástrojem \href{https://github.com/dependabot}{Dependabot}, který upozorňuje na známé bezpečnostní chyby v závislostech.

Po všech uživatelích vyžadujeme silná hesla, která jsou bezpečně uložena.
V tomto případě nebylo možné se vyhnout použití hesel, jelikož nemáme o uživatelích dostatek informací (např.\ e-mail, telefonní číslo apod.).

Webové rozhraní používající knihovnu NextJS ve výchozím nastavení sbírá anonymní data o uživatelích.
Na dotaz zadavatele byl sběr těchto dat vypnutý pro zvýšení důvěry uživatelů v platformu (viz produkční Dockerfile kontejneru \texttt{web-app}).
(Detailní informace o sbíraných datech knihovnou NextJS jsou dostupné na této \href{https://nextjs.org/telemetry}{stránce}.)

Software Form.io nesbírá žádná data o uživatelích (viz \href{https://github.com/formio/formio/issues/1499}{vyjádření společnosti}).


\section{GDPR}\label{sec:gdpr}

Při autentizaci uživatele používáme cookies pro správu session.
Ukládání dat do úložiště klienta spadá pod \href{https://eur-lex.europa.eu/eli/reg/2016/679/oj}{GDPR}, proto je nutno ověřit, jaké jsou naše povinnosti.
Dle \href{https://ec.europa.eu/justice/article-29/documentation/opinion-recommendation/files/2012/wp194_en.pdf}{doporučení Evropské Unie (sekce 3.2)} pro autentizační cookies je potřeba pro \emph{persistentní} cookies upozornit uživatele o jejich užití.
Knihovna NextAuth.js, kterou používáme má podporu pouze pro persistentní cookies (viz \href{https://github.com/nextauthjs/next-auth/issues/2534}{issue}), tedy musíme uživatele řádně upozornit.
Pro tento účel jsem zvolil knihovnu \href{https://www.npmjs.com/package/react-cookie-consent}{react-cookie-consent}.

% TODO: ověřit u NUDZ
GDPR také vyžaduje, aby uživatelé měli možnost smazat svá data.
Existuje však výjimka ohledně ukládání vědeckých dat.
Veškerá data, která ukládáme slouží mimo jiné pro vědecké účely.


\section{Autentizace}\label{sec:auth}

Uživatelé se přihlašují pomocí náhodně generovaného ID a hesla.
Administrátoři se přihlašují pomocí e-mailu a hesla.
Pro autentifikaci se používá knihovna NextAuth.js, která vykonává kód jak na klientovi, tak na serveru webové aplikace.
Tato knihovna má vlastní session management a vydává JWT tokeny.
Aby klient mohl pracovat se systémem spravující formuláře, je potřeba získat JWT token systému spravující formuláře.
Token systému spravující formuláře je vložen do tokenu vydávaného knihovnou NextAuth.js.
Tento systém zařizuje, že webová aplikace nemusí při každém požadavku od klienta komunikovat s formulářovým systémem, ale má vlastní session.
Kontrola práv uživatele při přístupu na ochráněnou stránku se kontrola provádí v middleware NextJS serveru.

\begin{figure}[H]
    \includegraphics[width=0.9\textwidth]{diagrams/auth}
    \caption{Komunikace při autentizaci uživatele}\label{fig:auth}
\end{figure}


\section{Konfigurace a modifikace Form.io}\label{sec:konfigurace-a-modifikace-form.io}

Subrepozitář \texttt{/src/formio/} obsahuje fork projektu Form.io, kde bylo provedeno několik úprav.
Tyto úpravy jsou popsány v této sekci popsány v této sekci.
Dále jsou zde popsány některé části konfigurace Form.io.

\subsection{Modifikace}\label{subsec:modifikace}

\subsubsection{Inicializace projektu}\label{subsubsec:inicializace-projektu}

První úprava se týče inicializace instance při prvním startu.
Nepodařilo se mi najít způsob, jak nakonfigurovat inicializaci projektu tak, aby se automaticky vytvořili všechny potřebné zdroje (klient, pacient, zaměstnanec, apod.), role (admin, zaměstnanec, apod.).
Proto jsem upravil kód inicializace tak, aby se načetla z souboru \texttt{project.json} z kořenu subrepozitáře.
Původně se načítala z \texttt{project.json} v build složce, která však není uložena ve verzovacím systému.
Tato úprava byla nutná, jelikož nelze vytvářet nové role po inicializaci projektu a konfigurační soubor je nutné zahrnout do verzovacícho systému.

\subsubsection{Webhook action}\label{subsubsec:webhook-action}

Webhook action je koncept software Form.io, který umožňuje poslat HTTP dotaz na zadanou URL jako reakci na určitou událost (např.\ vytvoření nebo smazání formuláře).
V open-source verzi Form.io software tato funkce neumí přeposílat hlavičky HTTP dotazu, který požadavek inicioval.
Tuto funkcionalitu potřebujeme, jelikož chceme přeposílat autentifikační hlavičky při komunikaci mezi systémem spravující formuláře a systémem spravující úkoly uživatelů.
Detaily ohledně této komunikace jsou popsány v sekci\ \ref{sec:propojeni-spravy-ukolu-a-spravy-formularu}.
Proto jsem upravil tuto funkci tak, aby bylo možné přeposílat autentifikační hlavičky.

\subsubsection{Imutabilita ID uživatele}\label{subsubsec:imutabilita-id-uzivatele}

Form.io software reprezentuje jednotlivé uživatele jako vyplnění registračního formuláře.
My potřebujeme zajistit imutabilitu identifikátoru uživatele, který je uložen v položce \texttt{data.id}.
Motivaci k této změně naleznete v sekci~\ref{sec:auth}.
Databáze \href{https://www.mongodb.com/}{MongoDB}, která je použita pro ukládání dat o uživatelích neumí zajistit imutabilitu ukládaných dat.
Form.io však vždy přistupuje k databázi uživatelů skrze knihovnu \href{https://mongoosejs.com/}{Mongoose}.
Tato knihovna umí zajistit imutability zvolených položek.
Mongoose nakonfigurujeme tak, aby zajistil imutabilitu položky \texttt{data.id} (ID uživatele).
Pokud se uživatel pokusí změnit své ID v rámci úpravy svého profilu, tak se změna neprovede.
Nevýhodou tohoto řešení je, že vytváří omezení na položky \texttt{data.id} ve všech objektech reprezentující odevzdání, tedy i v těch, které nejsou uživatelské účty.

Alternativní řešení by bylo vytvořit autorizační proxy mezi klientem a Form.io serverem či mezi Form.io serverem a databází uživatelů.
Toto řešení by pravděpodobně vyžadovalo další kontejner a má netriviální implementaci.
Implementace by navíc měla nízkou odolnost vůči změnám.
Pokud bychom měli více koncových bodů API, které umožňují modifikovat entitu uživatele, bylo by potřeba myslet na zabezpečení všech koncových bodů.
V případě přidání nového bodu, by bylo vždy potřeba myslet na úpravy autorizační proxy.
Z těchto důvodů byla tato alternativa zavrhnuta a bylo použito řešení popsáno v předchozím odstavci.

\subsection{Konfigurace}\label{subsec:konfigurace}

\subsubsection{Konfigurace zdrojů (resources)}\label{subsubsec:konfigurace-resources}

Roli lze k uživateli přiřadit pouze skrze akci (action), která je přiřazena k zdroji (resource).
Proto je potřeba vytvořit resource pro každou kombinaci rolí, kterou chceme vytvořit.
Vzhledem k tomu, že jsou zdroje oddělené, nelze při tvorbě uživatelského účtu jednoduše validovat, že má každý uživatel unikátní ID pro přihlášení.
Abychom předešli zmatení uživatelů, v uživatelském rozhraní vždy k ID přidáme i roli, která je uživateli přiřazena.

Alternativně bychom mohli každé existující kombinaci rolí přidat prefix do ID uživatele.
Toto řešení však značně zhoršuje uživatelskou zkušenost a proto bylo zavrhnuto.

\section{Propojení správy úkolů a správy formulářů}\label{sec:propojeni-spravy-ukolu-a-spravy-formularu}

Potřebujeme propojit komponentu starající se o úkolu a komponentu starající se o formuláře.
Zde je seznam požadovaného chování:

\begin{itemize}
    \item
    Úkol drží informaci o ID vyplnění dotazníku splnění úkolu nebo dotazník drží informaci o ID úkolu v rámci kterého byl vyplněn.
    \item
    Uživatel může vyplnit dotazník, právě tehdy když má dotazník ve svých úkolech.
\end{itemize}

\subsection{Řešení}\label{subsec:reseni}

\subsubsection{Alternativa 1}\label{subsubsec:alternativa-1}

Uživatel vyplní dotazník a \emph{odešle se požadavek na komponentu spravující formuláře}, kde je připraven webhook, který proběhne \emph{před} uložením výsledku, kde proběhne kontrola existence úkolu na vyplnění tohoto dotazníku.
Pokud úkol existuje, tak se vyplnění dotazníku uloží společně s identifikátorem úkolu a také se splní úkol a uloží se k němu identifikátor vyplnění dotazníku.

Dále bychom potřebovali v dotazníku vytvořit skryté pole, které obsahuje identifikátor úkolu v rámci, kterého byl dotazník vyplněn.
Tím zajistíme, že vyplnění dotazníku drží informaci o identifikátoru úkolu v rámci kterého byl vyplněn.

\subsubsection{Alternativa 2}\label{subsubsec:alternativa-2}

Uživatel vyplní dotazník a \emph{odešle se požadavek na komponentu spravující úkoly}, která za něj dotazník odevzdá pokud má uživatel úkol na jeho vyplnění.
Situace se při tomto řešení komplikuje, jelikož bychom museli zajistit, že všechny požadavky na vyplnění dotazníku musí jít skrze komponentu spravující úkoly.
Museli bychom tedy zakázat, aby uživatel odevzdal dotazník přímo do systému spravující formuláře.
Kdybychom to neudělali, tak nejsme schopni zajistit integritu sesbíraných dat.
Toto omezení bychom mohli zajistit úpravou konfigurace reverse proxy, kterou prochází všechny požadavky z vnějšího světa.
Tento způsob by však nezajistil ochranu před požadavky z vnitřní sítě.
Pro ochranu před požadavky z vnitřní sítě bychom veškerou komunikaci s systémem spravující formuláře skrze autentifikační proxy.

\subsubsection{Finální implementace}\label{subsubsec:finalni-implementace}

Zvolme první alternativu, jelikož je jednodušší na implementaci a má lepší vlastnosti.
Nyní si rozmysleme detaily implementace.
Chceme zajistit, aby se nám nepodařilo vytvořit více vyplnění dotazníku pro stejný úkol.
Proto formulář, který bude zadáván jako úkol pro plnitele, nastavíme tak, aby zajistil unikátnost hodnoty skryté položky obsahující identifikátor úkolu.
Nyní popišme proces vyplnění dotazníku formou diagramu aktivit.

\begin{figure}[H]
    \centering
    \includegraphics[height=0.7\textwidth, angle=90]{diagrams/activityDiagramTaskAndFormIntegration}
    \caption{Diagram integrace systémů spravující úkoly a systému spravující formuláře}\label{fig:activity-diagram-task-and-form-integration}
\end{figure}

V rámci reakce na první webhook uvedeme úkol do stavu \texttt{skoro hotový}.
Tento stav slouží k tomu, aby nebylo možné vytvořit další vyplnění dotazníku v rámci stejného úkolu.
Tento mechanismus se nazývá \emph{semantic lock counter-measure} dle \href{https://microservices.io/post/microservices/2019/07/09/developing-sagas-part-1.html}{tohoto článku}.

Po uložení vyplnění dotazníku se zavolá druhý webhook, který zařídí uložení informace o identifikátoru vyplnění do úkolu.
Vzhledem k tomu, že se jedná o veřejně dostupný endpoint, tak je nutné ověřit poskytnutá data.
Musíme si tedy z úkolového systému vyžádat vyplnění dotazníku a zkontrolovat všechny náležitosti.
Pokud by se někdo pokusil spárovat úkol s formulářem, který je ve stavu \texttt{skoro hotový} na jiné vyplnění dotazníku než to, které způsobilo přechod úkolu do stavu \texttt{skoro hotový}, tak se mu to jistě nepovede.
Pokud by se někdo pokusil spárovat úkol s vyplněním dotazníku, který neodpovídá dotazníku zadaný úkolem, tak operace jistě selže.
Pokud by se někdo pokusil spárovat jiné vyplnění stejného dotazníku, tak se mu to také nepovede.
Ono jiné vyplnění dotazníku by muselo mít jiný identifikátor úkolu v skrytém poli, protože systém spravující formuláře zajišťuje unikátnost těchto hodnot.
Jelikož víme, že již existuje vyplnění dotazníku, které má identifikátor úkolu v skrytém poli stejné jako identifikátor úkolu, který se právě snažíme napárovat, tak víme, že jakékoliv jiné vyplnění stejného dotazníku bude mít jiný identifikátor úkolu v skrytém poli.

\paragraph{Autentifikace webhooku}

První možnost je poskytnout webhooku speciální přístupový token.
Toto však nelze provést pouze pro jeden webhook bez většího zásahu do zdrojového kódu systému spravující formuláře, ale pouze pro všechny webhooky najednou.
Navíc to situaci zbytečně komplikuje.

Druhá možnost je využití JWT tokenu z požadavku na formulářový systém.
Toto je dobrá možnost, ale open-source verze formulářového systému tuto funkci nemá.
Nicméně není těžké ji do něj přidat.

Třetí možností je vyhnout se autentifikaci webhooku pomocí přihlášení.
Místo toho bychom mohli vytvořit endpoint komponenty spravující úkoly, který je přístupný pouze z komponenty spravující formuláře.
Toto však znamená netriviální úpravy síťové infrastruktury.
Tyto úpravy jsou poměrně špatně udržovatelné.

Zvolme druhou možnost, jelikož má jednoduchou implemetaci.
Provedené úpravy systému spravující formuláře jsou popsány v sekci~\ref{sec:konfigurace-a-modifikace-form.io}.

\subsection{Stavy úkolu}\label{subsec:stavy-ukolu}

\begin{figure}[H]
    \includegraphics[width=0.9\textwidth]{diagrams/taskState}
    \caption{Stavový diagram úkolů}\label{fig:task-state}
\end{figure}


Pokud požadavek na uložení vyplnění dotazníku spustí webhook, který proběhne před uložením do systému spravující formuláře, a následně selže operace uložení vyplnění dotazníku v systému spravující formuláře, tak se úkol navždy zůstane ve stavu \texttt{skoro hotový}.
Pokud bychom se z tohoto stavu chtěli dostat, potřebovali bychom implementaci \href{https://microservices.io/patterns/data/saga.html}{ság}, která by zajistila provedení kompenzačních transakcí.
Popsaná situace je však natolik výjimečná, že se v tuto chvíli problematice věnovat nebudeme.
Vystačíme si s tím, že systém spravující formuláře nikdy nebude obsahovat vyplnění dotazníku, které vzniklo bez zadání úkolu.

